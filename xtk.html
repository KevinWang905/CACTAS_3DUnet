<html>
<head>
<script type="text/javascript" src="https://get.goXTK.com/xtk11preview.js"></script>

<!-- for local debugging only -->
<!-- <script type="text/javascript" src="../get/xtk11preview.js"></script> -->
<!-- <script type="text/javascript" src="../X/lib/google-closure-library/closure/goog/base.js"></script> -->
<!-- <script type="text/javascript" src="../X/xtk-deps.js"></script> -->
<!-- for local debugging only -->

<style>
html, body { 
  background-color:#000;
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden !important;  
}
</style>

<script>

  //<!-- for local debugging only -->
  // goog.require('X.renderer2D');
  // goog.require('X.volume');
  //<!-- for local debugging only -->

  window.onload = function() {

    r = new X.renderer2D();
    r.orientation = 'y';
    r.init();

    v = new X.volume();
    // v.file = 'p.nii.gz';
    v.file = 'avf.nrrd';

    r.add(v);

    r.render();

    current_label = 1;

    let last_pixel = null;

    r.onShowtime = function() {

      v.createEmptyLabelMap();
      v.labelmap.opacity = 0.7;

      r.interactor.onMouseMove = function(e) {
        
        if (!e.ctrlKey) return;

        e.cancel = true; // no window/level adjustment

        ijk = r.xy2ijk(e.clientX, e.clientY)
        if (!ijk) return;


        last_pixel = ijkConvert(ijk);
        // console.log(last_pixel);
        let [i, j, k] = last_pixel;
       
        v.labelmap.setPixel(i, j, k, current_label);
      }

      r.interactor.onMouseUp = function(e) {

        v.refresh(); // only now redraw

        let [i, j, k] = last_pixel;

        // 8 neighbor directions
        const dk = [1, 1, 0, -1, -1, -1, 0, 1];
        const di = [0, -1, -1, -1, 0, 1, 1, 1];
        let visited = [];

        // find existing adjacent annotation
        // return ijk coords of where an existing annotation was encountered
        function findAdjacentAnnotation(i, j, k) {
          let label = v.labelmap.getPixel(i, j, k);
          visited.push([i, j, k]);


          if (label != current_label) {
            v.refresh();
            return [i, j, k];
          } else {
            for (let x = 0; x < 8; x++) {
              let next_px = [i + di[x], j, k + dk[x]];
              if (!visited.some(a => next_px.length && next_px.every((v, i) => v === a[i])) && v.labelmap.getPixel(i + di[x], j, k + dk[x]) != 0) {
                let r = findAdjacentAnnotation(i + di[x], j, k + dk[x]);
                if (r != null) return r;
              }
            }
            return null;
          }
      }

      function fillAnnotation(i, j, k, label) {
        console.log(`[fill] current pixel: (${i}, ${j}, ${k}) : label(${label})`);
        v.labelmap.setPixel(i, j, k, label);

        if (p = v.labelmap.getPixel(i + 1, j, k) > 0 && p != label) {
          fillAnnotation(i + 1, j, k, label);
        }
        if (p = v.labelmap.getPixel(i - 1, j, k) > 0 && p != label) {
          fillAnnotation(i - 1, j, k, label);
        }
        // if (p = v.labelmap.getPixel(i, j, k + 1) > 0 && p != label) {
        //   fillAnnotation(i, j, k + 1, label);
        // }
        // if (p = v.labelmap.getPixel(i, j, k - 1) > 0 && p != label) {
        //   fillAnnotation(i, j, k - 1, label);
        // }
      }
      

      visited = [];
      let newLabel = findAdjacentAnnotation(i, j, k);
      //console.log(newLabel);
      if (newLabel) {
        [i, j, k] = newLabel;
        v.labelmap.setPixel(i, j, k, 4); // debug
        v.refresh();
      }

      v.refresh();
    }

    function ijkConvert(ijk) {
      let i = Math.max(0, ijk[1][0].toFixed(0));
      let j = Math.max(0, ijk[1][1].toFixed(0));
      let k = Math.max(0, ijk[1][2].toFixed(0));

      return [i, j, k];
    }

  }
}


</script>

</head>

<body></body>

</html>